(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{440:function(t,v,_){"use strict";_.r(v);var e=_(2),s=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"mysql-事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql-事务"}},[t._v("#")]),t._v(" MySQL - 事务")]),t._v(" "),v("h2",{attrs:{id:"事务简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务简介"}},[t._v("#")]),t._v(" 事务简介")]),t._v(" "),v("p",[v("strong",[t._v("事务是逻辑上的一组操作, 要么都执行 ,要么都不执行")])]),t._v(" "),v("p",[t._v("事务最经典也经常被拿出来说例子就是转账了. 假如小明要给小红转账1000元, 这个转账会涉及到两个关键操作就是 : 将小明的余额减少1000元, 将小红的余额增加1000元. 万一在这两个操作之间突然出现错误比如银行系统崩溃, 导致小明余额减少而小红的余额没有增加, 这样就不对了. 事务就是保证这两个关键操作要么都成功, 要么都要失败")]),t._v(" "),v("h2",{attrs:{id:"事务的特性-acid"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的特性-acid"}},[t._v("#")]),t._v(" 事务的特性 (ACID)")]),t._v(" "),v("p",[t._v("事务包含四个特性, 简称为 "),v("strong",[t._v("ACID")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("原子性")]),t._v(" : 事务是最小的执行单位, 不允许分割. 事务的原子性确保动作要么全部完成, 要么完全不起作用")]),t._v(" "),v("li",[v("strong",[t._v("一致性")]),t._v(" : 执行事务前后, 事务保持一致, 例如转账业务中, 无论事务是否成功, 转账者和收款人的总额应该是不变的")]),t._v(" "),v("li",[v("strong",[t._v("隔离性")]),t._v(" : 并发访问数据库时, 一个用户的事务不被其他事务所干扰, 各并发事务之间数据库是独立的")]),t._v(" "),v("li",[v("strong",[t._v("持久性")]),t._v(" :   一个事务被提交之后, 它对数据库中的数据的改变是持久的, 即使数据库发送故障也不应该对其有任何影响")])]),t._v(" "),v("blockquote",[v("p",[t._v("图示")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://typora-photo-yixihan.oss-cn-chengdu.aliyuncs.com/img/image-20220708161516265.png",alt:"image-20220708161516265"}})]),t._v(" "),v("h2",{attrs:{id:"并发事务带来的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发事务带来的问题"}},[t._v("#")]),t._v(" 并发事务带来的问题")]),t._v(" "),v("p",[t._v("在典型的应用程序中, 多个事务并发运行, 经常会操作相同的数据来完成各自的任务 (多个用户对统一数据进行操作). 并发虽然是必须的, 但可能会导致以下的问题")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("脏读 (Dirty Read)")]),t._v(' : 当一个事务正在访问数据并且对数据进行了修改, 而这种修改还没有提交到数据库中, 这时另外一个事务也访问了这个数据, 然后使用了这个数据. 因为这个数据是还没有提交的数据, 那么另外一个事务读到的这个数据是"脏数据", 依据"脏数据"所做的操作可能是不正确的')]),t._v(" "),v("li",[v("strong",[t._v("丢失修改 (Lost to Modify)")]),t._v(" : 指在一个事务读取一个数据时, 另外一个事务也访问了该数据, 那么在第一个事务中修改了这个数据后, 第二个事务也修改了这个数据. 这样第一个事务内的修改结果就被丢失, 因此称为丢失修改.  例如 :事务 1 读取某表中的数据 "),v("code",[t._v("A = 20")]),t._v(", 事务 2 也读取 "),v("code",[t._v("A = 20")]),t._v(", 事务 1 修改 "),v("code",[t._v("A = A - 1")]),t._v(", 事务 2 也修改 "),v("code",[t._v("A = A - 1")]),t._v(" , 最终结果 "),v("code",[t._v("A = 19")]),t._v(", 事务 1 的修改被丢失")]),t._v(" "),v("li",[v("strong",[t._v("不可重复读 (Unrepeatableread)")]),t._v(" : "),v("strong",[t._v("指在一个事务内多次读同一数据")]),t._v(". 在这个事务还没有结束时, 另一个事务也访问该数据. 那么, 在第一个事务中的两次读数据之间, 由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样. 这就发生了在一个事务内两次读到的数据是不一样的情况, 因此称为不可重复读")]),t._v(" "),v("li",[v("strong",[t._v("幻读 (Phantom Read)")]),t._v(" :  幻读与不可重复读类似. 它发生在一个事务（T1）读取了几行数据. 接着另一个并发事务（T2）插入了一些数据时. 在随后的查询中, 第一个事务（T1）就会发现多了一些原本不存在的记录, 就好像发生了幻觉一样, 所以称为幻读")])]),t._v(" "),v("blockquote",[v("p",[t._v("不可重复度和幻读区别")])]),t._v(" "),v("p",[t._v("不可重复读的重点是"),v("strong",[t._v("修改")]),t._v(", 幻读的重点在于"),v("strong",[t._v("新增或者删除")])]),t._v(" "),v("p",[t._v("例1 (同样的条件, 你读取过的数据, 再次读取出来发现值不一样了)  : 事务 1 中的 A 先生读取自己的工资为 1000 的操作还没完成, 事务 2 中的 B 先生就修改了 A 的工资为 2000, 导致 A 再读自己的工资时工资变为 2000; 这样就导致了不可重复读")]),t._v(" "),v("p",[t._v("例2 (同样的条件,  第 1 次和第 2 次读出来的记录数不一样) : 假某工资单表中工资大于 3000 的有 4 人, 事务 1 读取了所有工资大于 3000 的人, 共查到 4 条记录, 这时事务 2 又插入了一条工资大于 3000 的记录, 事务 1 再次读取时查到的记录就变为了 5 条; 这样就导致了幻读。")]),t._v(" "),v("h2",{attrs:{id:"事务隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[t._v("#")]),t._v(" 事务隔离级别")]),t._v(" "),v("p",[t._v("SQL 标准定义了四个隔离级别 :")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("READ-UNCOMMITTED (读取未提交)")]),t._v(" : 最低的隔离级别, 允许读取尚未提交的数据变更, "),v("strong",[t._v("可能会导致脏读、幻读或不可重复读")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("READ-COMMITTED (读取已提交)")]),t._v(" : 允许读取并发事务已经提交的数据, "),v("strong",[t._v("可以阻止脏读, 但是幻读或不可重复读仍有可能发生")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("REPEATABLE-READ (可重复读)")]),t._v(" : 对同一字段的多次读取结果都是一致的, 除非数据是被本身事务自己所修改, "),v("strong",[t._v("可以阻止脏读和不可重复读, 但幻读仍有可能发生")])]),t._v(" "),v("li",[v("strong",[t._v("SERIALIZABLE (可串行化)")]),t._v(" : 最高的隔离级别, 完全服从 ACID 的隔离级别. 所有的事务依次逐个执行, 这样事务之间就完全不可能产生干扰, 也就是说, "),v("strong",[t._v("该级别可以防止脏读、不可重复读以及幻读")])])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("隔离级别")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("脏读")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("不可重复读")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("幻读")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("READ-UNCOMMITTED")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("READ-COMMITTED")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("REPEATABLE-READ")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("SERIALIZABLE")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("×")])])])]),t._v(" "),v("h3",{attrs:{id:"修改-mysql-隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#修改-mysql-隔离级别"}},[t._v("#")]),t._v(" 修改 MySQL 隔离级别")]),t._v(" "),v("p",[v("code",[t._v("MySQL InnoDB")]),t._v(" 存储引擎的默认支持的隔离级别是 "),v("strong",[t._v("REPEATABLE-READ（可重读）")])]),t._v(" "),v("p",[t._v("查看隔离级别命令")]),t._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# mysql 5.7")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" @"),v("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@tx_isolation")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# mysql 8.0")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" @"),v("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@transaction_isolation")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br")])]),v("blockquote",[v("p",[t._v("小贴士")])]),t._v(" "),v("p",[v("strong",[t._v("MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读, 需要应用使用加锁读来保证. 而这个加锁读使用到的机制就是 Next-Key Locks。")])]),t._v(" "),v("p",[t._v("因为隔离级别越低, 事务请求的锁越少, 所以大部分数据库系统的隔离级别都是 "),v("strong",[t._v("READ-COMMITTED(读取提交内容)")]),t._v(" , 但是你要知道的是 "),v("code",[t._v("InnoDB")]),t._v(" 存储引擎默认使用 "),v("strong",[t._v("REPEATABLE-READ（可重读）")]),t._v(" 并不会有任何性能损失")]),t._v(" "),v("p",[t._v("InnoDB 存储引擎在 "),v("strong",[t._v("分布式事务")]),t._v(" 的情况下一般会用到 "),v("strong",[t._v("SERIALIZABLE(可串行化)")]),t._v(" 隔离级别")])])}),[],!1,null,null,null);v.default=s.exports}}]);