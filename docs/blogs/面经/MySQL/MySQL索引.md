---
title: MySQL - 索引
date: 2022-10-30T17:55:28+08:00
sidebar: 'auto'
categories:
- 面经
- MySQL
tags:
- MySQL
- 面经
---

# MySQL - 索引



## 索引概念

**索引是一种用于快速查询和检索数据的数据结构**

索引的作用就相当于目录的作用



>   常见索引数据结构

-   B 树
-   B+ 树
-   Hash



## 索引的优缺点

>   优点

-   使用索引可以大大加快 **数据的检索速度 (减少检索的数据量)**
-   通过创建唯一性索引, 可以保证数据库表中每一行数据的唯一性 (主键索引)



>   缺点

-   创建索引和维护索引需要耗费许多时间, 对表中的数据进行更新的时候 (增删改), 如果涉及到索引, 索引也需要进行更新, 会降低 SQL 的执行效率
-   索引也需要物理文件存储, 会耗费一定空间



>   总结

大多数情况下, 索引查询都是比全表查询要快的, 但是如果数据库的数据量不大, 那么使用索引也不一定能带来很大的提升



## 索引的底层数据结构



索引的底层数据结构主要为以下三种

-   Hash 表
-   B 树
-   B+ 树



目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构. 



### Hash表

#### 简介

哈希表是键值对的集合, 通过键 (key) 即可快速取出对应的值 (value), 因此哈希表可以快速检索数据 (时间复杂度接近 O(1))



#### 原理

哈希表之所以可以通过 key 快速取出 value, 原因在于 **哈希算法 (散列算法)**

通过哈希算法, 我们可以快速找到 key 对应的 value, 找到了 index 也就找到了对应的 value

```java
hash = hashfunc (key);
index = hash % array_size;
```

![img](https://typora-photo-yixihan.oss-cn-chengdu.aliyuncs.com/img/20210513092328171.png)

#### 优缺点

>   优点

-   检索速度非常快 (接近 O(1))



>   缺点

-   存在哈希冲突问题
-   **不支持顺序和范围查询**



### B 树

#### 简介

B 树也称为 B- 树, 全称为 **多路平衡查找树**

其中 B 树中的 B 是 平衡 (Balanced) 的意思



#### 原理

一颗 m 阶的 B 树定义如下 :

-   每个节点最多有 m - 1个关键字
-   根节点最少可以只有一个关键字
-   非根节点至少有 Math.ceil (m / 2) - 1 个关键字
-   每个节点中的关键字都按照从小到大的顺序排列, 每个关键字的左子树中所有的关键字都小于它, 而右子树中的所有关键字都大于它
-   所有叶子节点都位于同一层, 或者说根节点到每个叶子节点的长度都相同

![clip_image002](https://typora-photo-yixihan.oss-cn-chengdu.aliyuncs.com/img/834468-20180406232634472-395289491.png)

上图是一颗阶数为4的B树. 在实际应用中的 B 树的阶数 m 都非常大 (通常大于100), 所以即使存储大量的数据, B树的高度仍然比较小. 每个结点中存储了关键字 (key) 和关键字对应的数据 (data), 以及孩子结点的指针. **我们将一个 key 和其对应的 data 称为一个记录**. 在数据库中我们将 B 树作为索引结构, 可以加快查询速速, 此时 B 树中的 key 就表示键, 而 data 表示了这个键对应的条目在硬盘上的逻辑地址



### B+ 树

#### 简介

B+ 树是 B 树的一种变体



#### 原理

一颗 B+ 树的定义如下 :

-   关键字个数比孩子节点数小 1
-   B+ 树包含两种类型的节点 : 内部节点 (索引节点) 和叶子节点.
    -   根节点本身既可以是内部节点, 也可以是叶子节点
    -   根节点的关键字最少可以只有一个
-   B+ 树与 B 树最大的不同是内部节点不保存数据, 只用于索引, 所有数据都保存在叶子节点中
-   m 阶 B+ 树表示了内部节点最多有 m - 1 个关键字 (或者说内部节点最多有 m 个子树), 阶段 m 同时限制了叶子节点最多存储 m - 1 个数据
-   内部节点中 key 都按照从小到大的顺序排序, 对于内部节点的一个 key, 左子树中所有 key 都小于它, 右子树中所有 key 都大于它. 叶子节点中的数据也按照 key 的大小排列
-   每个叶子节点都存有相邻叶子节点的指针, 叶子节点本身依关键字的大小自小而大顺序链接



![clip_image039](https://typora-photo-yixihan.oss-cn-chengdu.aliyuncs.com/img/834468-20180406232854940-1019144331.png)

### B 树和 B+ 树的异同

-   B 树中所有节点既存放键 (key), 也存放 数据(data), 而 B+ 树中只有叶子节点存放 key 和 data, 其他节点只存放 key
-   B 树的叶子节点都是独立的, 而 B+ 树的叶子节点有一条引用链指向与它相邻的叶子节点
-   B 树的索引过程相当于对范围内的每个关键字做二分查找, 可能还没到达叶子节点, 检索就结束了, 而 B+ 树的检索效率就很稳定了, 任何查找都是从根节点到叶子节点的过程, 叶子节点的顺序检索很明显



>   B 树 和 B+ 树的相关博客

[B 树 和 B+ 树的插入删除详解](https://www.cnblogs.com/nullzx/p/8729425.html)



### MyISAM 和 InnoDB 对于 B+ 树实现方式

>   MyISAM

MyISAM 引擎中, B+Tree 叶节点的 data 域存放的是数据记录的地址. 在索引检索的时候, 首先按照 B+Tree 搜索算法搜索索引, 如果指定的 Key 存在, 则取出其 data 域的值, 然后以 data 域的值为地址读取相应的数据记录. **这被称为 "非聚簇索引"**



>   InnoDB

InnoDB 引擎中, 其数据文件本身就是索引文件. 相比 MyISAM, 索引文件和数据文件是分离的, 其表数据文件本身就是按 B+Tree 组织的一个索引结构, 树的叶节点 data 域保存了完整的数据记录. 这个索引的 key 是数据表的主键, 因此 InnoDB 表数据文件本身就是主索引. **这被称为 "聚簇索引（或聚集索引）"**

而其余的索引都作为辅助索引, 辅助索引的 data 域存储相应记录主键的值而不是地址, 这也是和 MyISAM 不同的地方. 在根据主索引搜索时, 直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时, 则需要先取出主键的值, 再走一遍主索引.  因此, 在设计表的时候, 不建议使用过长的字段作为主键, 也不建议使用非单调的字段作为主键, 这样会造成主索引频繁分裂



## 索引类型

### 主键索引 (Primary Key)

数据库的主键列使用的索引就是主键索引

一张数据表只能有一个主键, 并且 **主键不能为 null, 不能重复**

在 MySQL 的 InnoDB 的表中, 当没有显示的指定表的主键时, InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段, 如果有, 则选择该字段为默认的主键, 否则 InnoDB 将会自动创建一个 6Byte 的自增主键



### 二级索引 (辅助索引)

**二级索引也称为辅助索引, 是因为二级索引的叶子节点存储的数据是 ==主键==, 也就是说, 通过二级索引, 可以定位主键的位置**

唯一索引, 普通索引, 前缀索引, 联合索引等索引都属于二级索引



-   **唯一索引 (Unique Key)** : 唯一索引也是一种约束. **唯一索引的属性列不能出现重复的数据, 但是允许数据为 null, 一张表允许创建多个唯一索引**. 建立唯一索引的目的大部分都是为了该属性列的唯一性, 而非查询效率
-   **普通索引 (Index)** : **普通索引的唯一作用就是为了快速查询数据, 一张表允许创建多个普通索引, 并允许数据重复和 null**
-   **前缀索引 (Prefix)** : 前缀索引只适合字符串类型的数据. 前缀索引是对文本的前几个字符创建索引, 相比普通索引建立的数据更小
-   **全文索引 (Full Text)** : 全文索引主要是为了检索大文本数据中的关键字信息, 是目前搜索引擎数据库使用的一种技术. Mysql 5.6 之前只有 MyISAM 引擎支持全文索引. 5.6之后 InnoDB 也支持了全文索引



>   二级索引数据结构示例

![img](https://typora-photo-yixihan.oss-cn-chengdu.aliyuncs.com/img/20210420165254215.png)



## 聚集索引与非聚集索引

### 聚集索引

#### 简介

**聚集索引级索引结构和数据一起存放的索引, 主键索引属于聚集索引**

在 MySQL 中, InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据, 对于 InnoDB 引擎表来说, 该表的索引 (B+ 树) 的每个非叶子节点存储索引, 叶子节点存储索引和索引对应的数据。



#### 优缺点

>   优点

聚集索引的查询速度非常的快, 因为整个 B+ 树本身就是一颗多叉平衡树, 叶子节点也都是有序的, 定位到索引的节点, 就相当于定位到了数据



>   缺点

1.   **依赖于有序的数据** : 因为 B+ 树是多路平衡树, 如果索引的数据不是有序的, 那么就需要在插入的时候排序, 插入或查找的速度就会比较慢
2.   **更新代价大** : 如果索引列的数据被修改时, 那么对应的索引也将会被修改, 且聚集索引的叶子节点还存放着数据, 修改代价肯定是比较大的, 所以对于主键索引来说, 主键一般都是不可修改的.



### 非聚集索引

#### 简介

**非聚集索引即索引结构和数据分开存放的索引**

二级索引属于非聚集索引

非聚集索引的叶子节点不一定存放数据的指针, 因为二级索引的叶子节点存放的就是主键, 根据主键再会标查数据



#### 优缺点

>   优点

1.   **更新的代码比聚集索引小** : 非聚集索引的更新代价没有聚集索引那么大, 因为非聚集索引的叶子节点是存放的主键或指针而非数据



>   缺点

1.   跟聚集索引一样, **非聚集索引也依赖于有序的数据**
2.   可能会**二次查询 (回表)** : 这应该就是非聚集索引最大的缺点了. 当查到索引对应的指针或主键后,可能还需根据指针或主键再到数据文件或表中查询

 

>   MySQL 表文件截屏

![img](https://typora-photo-yixihan.oss-cn-chengdu.aliyuncs.com/img/20210420165311654.png)



>   聚集索引和非聚集索引

![img](https://typora-photo-yixihan.oss-cn-chengdu.aliyuncs.com/img/20210420165326946.png)

### 非聚集索引一定回表查询吗(覆盖索引)?

**非聚集索引不一定会回表查询**



>   示例

用户准备使用 SQL 查询用户名, 而用户名字段正好建立了索引

那么这个索引的 key 本身就是 name, 查到对应的 name 直接返回就行了, 无需回表查询

```sql
SELECT name FROM table WHERE name = 'yixihan';
```

而当用户准备使用 SQL 通过用户名查询电话, 而用户名自字段建立了索引且用户电话字段没有建立索引, 这时候就会回表查询

```sql
SELECT phone FROM table WHERE name = "yixihan";
```



## 覆盖索引

### 简介

如果一个索引包含 (或者说覆盖) 所有需要查询的字段的值, 我们就称之为 "覆盖索引". 我们知道在 InnoDB 存储引擎中, 如果不是主键索引, 叶子节点存储的是主键 + 列值. 最终还是要"回表", 也就是要通过主键再查找一次. 这样就会比较慢

覆盖索引就是把要查询出的列和索引是对应的, 不做回表操作!

**覆盖索引即需要查询的字段正好是索引的字段, 那么直接根据该索引, 就可以查到数据了,  而无需回表查询**

如主键索引, 如果一条 SQL 需要查询主键, 那么正好根据主键索引就可以查到主键

再如普通索引, 如果一条 SQL 需要查询 name, name 字段正好有索引,  那么直接根据这个索引就可以查到数据, 也无需回表



>   覆盖索引

![img](https://typora-photo-yixihan.oss-cn-chengdu.aliyuncs.com/img/20210420165341868.png)



## 创建索引的注意事项

1.   **选择合适的字段创建索引** :

     1.   **不为 null 的字段** : 索引字段的数据应该尽量不为 null, 因为对于数据为 null 的字段, 数据库较难优化, 如果字段频繁被查询, 但又避免不了为 null, 建议使用 0, 1, true, false 这样语义较为清晰的短值或短字符作为替代
     2.   **被频繁查询的数据** : 创建索引的字段应该是查询操作非常频繁的字段
     3.   **被作为条件查询的字段** : 被作为 WHERE 条件查询的字段, 应该被考虑建立索引
     4.   **频繁需要排序的字段** : 索引已经排序, 这样查询可以利用索引的排序, 加快排序查询时间
     5.   **被经常频繁用于连接的字段** : 经常用于连接的字段可能是一些外键列, 对于外键列并不一定要建立外键, 只是说该列涉及到表与表的关系. 对于频繁被连接查询的字段, 可以考虑建立索引, 提高多表连接查询的效率

2.   **被频繁更新的字段应该慎重建立索引**

     虽然索引能带来查询上的效率, 但是维护索引的成本也是不小的.  如果一个字段不被经常查询, 反而被经常修改, 那么就更不应该在这种字段上建立索引了

3.   **尽可能的考虑建立联合索引而非单列索引**

     因为索引是需要占用磁盘空间的, 可以简单理解为每个索引都对应着一颗 B+ 树. 如果一个表的字段过多, 索引过多, 那么当这个表的数据达到一个体量后, 索引占用的空间也是很多的, 且修改索引时, 耗费的时间也是较多的. 如果是联合索引, 多个字段在一个索引上, 那么将会节约很大磁盘空间, 且修改数据的操作效率也会提升

4.   **注意避免冗余索引**

     冗余索引指的是索引的功能相同, 能够命中索引 (a, b) 就肯定能命中索引 (a) , 那么索引 (a) 就是冗余索引. 如 (name,city) 和 (name) 这两个索引就是冗余索引, 能够命中前者的查询肯定是能够命中后者的在大多数情况下, 都应该尽量扩展已有的索引而不是创建新索引

5.   **考虑在字符串类型的字段上使用前缀索引代替普通索引**

     前缀索引仅限于字符串类型, 较普通索引会占用更小的空间, 所以可以考虑使用前缀索引带替普通索引



## 使用索引的一些建议

-   对于中到大型表索引都是非常有效的, 但是特大型表的话维护开销会很大, 不适合搭建索引
-   避免 where 子句中对字段施加函数, 这样会造成无法命中索引
-   在使用 InnoDB 时使用业务无关的自增主键作为主键, 即使用逻辑主键, 而不要使用业务主键.
-   删除长期未使用的索引, 不用的索引的存在会造成不必要的性能损耗. MySQL 5.7 可以通过查询 sys 库中 schema_unused_indexes 视图来查询哪些索引从未被使用
-   在使用 limit offset 查询缓慢时, 可以借助索引来提高性能



## MySQL 为表字段添加索引

```sql
# 添加主键索引 (Primary Key)
ALTER TABLE `table_name` ADD PRIMARY KEY (`column`);

# 添加唯一索引 (UNIQUE)
ALTER TABLE `table_name` ADD UNIQUE (`column`);

# 添加普通索引 (INDEX)
ALTER TABLE `table_name` ADD INDEX index_name (`column`);

# 添加全文索引 (FULLTEXT)
ALTER TABLE `table_name` ADD FULLTEXT (`column`);

# 添加多列索引
ALTER TABLE `table_name` ADD INDEX index_name (`column1`, `column2`, `column3`);
```

