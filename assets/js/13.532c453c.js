(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{437:function(a,v,t){"use strict";t.r(v);var _=t(2),e=Object(_.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"bond"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bond"}},[a._v("#")]),a._v(" Bond")]),a._v(" "),v("h2",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),v("p",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/352814803",target:"_blank",rel:"noopener noreferrer"}},[a._v("Linux 网卡 bond 的七种模式详解"),v("OutboundLink")],1)]),a._v(" "),v("p",[a._v("网卡 "),v("code",[a._v("bond")]),a._v(" 是通过把多个物理网卡绑定为一个逻辑网卡，实现本地网卡的冗余，带宽扩容和负载均衡")]),a._v(" "),v("h2",{attrs:{id:"mode-0-链路负载均衡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mode-0-链路负载均衡"}},[a._v("#")]),a._v(" mode=0 (链路负载均衡)")]),a._v(" "),v("p",[v("strong",[a._v("mode=0(balance-rr)(平衡抡循环策略)")])]),a._v(" "),v("p",[a._v("链路负载均衡，增加带宽，支持容错，一条链路故障会自动切换正常链路。交换机需要配置聚合口，思科叫port channel。")]),a._v(" "),v("p",[a._v("特点：传输数据包顺序是依次传输（即：第1个包走eth0，下一个包就走eth1….一直循环下去，直到最后一个传输完毕），此模式提供负载平衡和容错能力；但是我们知道如果一个连接 或者会话的数据包从不同的接口发出的话，中途再经过不同的链路，在客户端很有可能会出现数据包无序到达的问题，而无序到达的数据包需要重新要求被发送，这样网络的吞吐量就会下降")]),a._v(" "),v("h3",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),v("ul",[v("li",[a._v("负载平衡")]),a._v(" "),v("li",[a._v("容错能力")])]),a._v(" "),v("h3",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),v("ul",[v("li",[a._v("在客户端很有可能会出现数据包无序到达的问题, 网络吞吐量会下降")])]),a._v(" "),v("h2",{attrs:{id:"mode-1-主备"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mode-1-主备"}},[a._v("#")]),a._v(" mode=1 (主备)")]),a._v(" "),v("p",[v("strong",[a._v("mode=1(active-backup)(主-备份策略)")])]),a._v(" "),v("p",[a._v("这个是主备模式，只有一块网卡是active，另一块是备用的standby，所有流量都在active链路上处理，交换机配置的是捆绑的话将不能工作，因为交换机往两块网卡发包，有一半包是丢弃的。")]),a._v(" "),v("p",[a._v("特点：只有一个设备处于活动状态，当一个宕掉另一个马上由备份转换为主设备。mac地址是外部可见得，从外面看来，bond的MAC地址是唯一的，以避免switch(交换机)发生混乱。此模式只提供了容错能力；由此可见此算法的优点是可以提供高网络连接的可用性，但是它的资源利用率较低，只有一个接口处于工作状态，在有 N 个网络接口的情况下，资源利用率为1/N")]),a._v(" "),v("h3",{attrs:{id:"优点-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("Mac")]),a._v(" 地址唯一, 避免交换机混乱")])]),a._v(" "),v("h3",{attrs:{id:"缺点-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),v("ul",[v("li",[a._v("资源利用率低")])]),a._v(" "),v("h2",{attrs:{id:"mode-2-平衡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mode-2-平衡"}},[a._v("#")]),a._v(" mode=2(平衡)")]),a._v(" "),v("p",[v("strong",[a._v("mode=2(balance-xor)(平衡策略)")])]),a._v(" "),v("p",[a._v("表示XOR Hash负载分担，和交换机的聚合强制不协商方式配合。（需要xmit_hash_policy，需要交换机配置port channel）")]),a._v(" "),v("p",[a._v("特点：基于指定的传输HASH策略传输数据包。缺省的策略是：(源MAC地址 XOR 目标MAC地址) % slave数量。其他的传输策略可以通过xmit_hash_policy选项指定，此模式提供负载平衡和容错能力")]),a._v(" "),v("h3",{attrs:{id:"优点-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),v("ul",[v("li",[a._v("负载平衡")]),a._v(" "),v("li",[a._v("容错能力")])]),a._v(" "),v("h2",{attrs:{id:"mode-3-广播"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mode-3-广播"}},[a._v("#")]),a._v(" mode=3(广播)")]),a._v(" "),v("p",[v("strong",[a._v("mode=3(broadcast)(广播策略)")])]),a._v(" "),v("p",[a._v("表示所有包从所有网络接口发出，这个不均衡，只有冗余机制，但过于浪费资源。此模式适用于金融行业，因为他们需要高可靠性的网络，不允许出现任何问题。需要和交换机的聚合强制不协商方式配合。")]),a._v(" "),v("p",[a._v("特点：在每个slave接口上传输每个数据包，此模式提供了容错能力")]),a._v(" "),v("h3",{attrs:{id:"优点-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点-4"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),v("ul",[v("li",[a._v("可靠性")]),a._v(" "),v("li",[a._v("容错能力")])]),a._v(" "),v("h3",{attrs:{id:"缺点-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),v("ul",[v("li",[a._v("过于浪费资源")])]),a._v(" "),v("h2",{attrs:{id:"mode-4-802-3ad"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mode-4-802-3ad"}},[a._v("#")]),a._v(" mode=4(802.3ad)")]),a._v(" "),v("p",[v("strong",[a._v("mode=4(802.3ad)(IEEE 802.3ad 动态链接聚合)")])]),a._v(" "),v("p",[a._v("表示支持802.3ad协议，和交换机的聚合LACP方式配合（需要xmit_hash_policy）.标准要求所有设备在聚合操作时，要在同样的速率和双工模式，而且，和除了balance-rr模式外的其它bonding负载均衡模式一样，任何连接都不能使用多于一个接口的带宽。")]),a._v(" "),v("p",[a._v("特点：")]),a._v(" "),v("ul",[v("li",[a._v("创建一个聚合组，它们共享同样的速率和双工设定。根据802.3ad规范将多个slave工作在同一个激活的聚合体下。")]),a._v(" "),v("li",[a._v("外出流量的slave选举是基于传输hash策略，该策略可以通过xmit_hash_policy选项从缺省的XOR策略改变到其他策略。需要注意的 是，并不是所有的传输策略都是802.3ad适应的，")]),a._v(" "),v("li",[a._v("尤其考虑到在802.3ad标准43.2.4章节提及的包乱序问题。不同的实现可能会有不同的适应 性。")])]),a._v(" "),v("p",[a._v("必要条件：")]),a._v(" "),v("ul",[v("li",[a._v("条件1：ethtool支持获取每个slave的速率和双工设定")]),a._v(" "),v("li",[a._v("条件2：switch(交换机)支持IEEE 802.3ad Dynamic link aggregation")]),a._v(" "),v("li",[a._v("条件3：大多数switch(交换机)需要经过特定配置才能支持802.3ad模式")])]),a._v(" "),v("h2",{attrs:{id:"mode-5-适配器负载均衡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mode-5-适配器负载均衡"}},[a._v("#")]),a._v(" mode=5(适配器负载均衡)")]),a._v(" "),v("p",[a._v("是根据每个slave的负载情况选择slave进行发送，接收时使用当前轮到的slave。该模式要求slave接口的网络设备驱动有某种ethtool支持；而且ARP监控不可用。")]),a._v(" "),v("p",[a._v("特点：不需要任何特别的switch(交换机)支持的通道bonding。在每个slave上根据当前的负载（根据速度计算）分配外出流量。如果正在接受数据的slave出故障了，另一个slave接管失败的slave的MAC地址。")]),a._v(" "),v("p",[a._v("必要条件：")]),a._v(" "),v("ul",[v("li",[a._v("ethtool支持获取每个slave的速率"),v("strong",[a._v("7、mode=6(balance-alb)(适配器适应性负载均衡)")])])]),a._v(" "),v("p",[a._v("在5的tlb基础上增加了rlb(接收负载均衡receive load balance).不需要任何switch(交换机)的支持。接收负载均衡是通过ARP协商实现的.")]),a._v(" "),v("p",[a._v("特点：该模式包含了balance-tlb模式，同时加上针对IPV4流量的接收负载均衡(receive load balance, rlb)，而且不需要任何switch(交换机)的支持。接收负载均衡是通过ARP协商实现的。bonding驱动截获本机发送的ARP应答，并把源硬件地址改写为bond中某个slave的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信。")]),a._v(" "),v("p",[a._v("来自服务器端的接收流量也会被均衡。当本机发送ARP请求时，bonding驱动把对端的IP信息从ARP包中复制并保存下来。当ARP应答从对端到达 时，bonding驱动把它的硬件地址提取出来，并发起一个ARP应答给bond中的某个slave。")]),a._v(" "),v("p",[a._v("使用ARP协商进行负载均衡的一个问题是：每次广播 ARP请求时都会使用bond的硬件地址，因此对端学习到这个硬件地址后，接收流量将会全部流向当前的slave。这个问题可以通过给所有的对端发送更新 （ARP应答）来解决，应答中包含他们独一无二的硬件地址，从而导致流量重新分布。")]),a._v(" "),v("p",[a._v("当新的slave加入到bond中时，或者某个未激活的slave重新 激活时，接收流量也要重新分布。接收的负载被顺序地分布（round robin）在bond中最高速的slave上 当某个链路被重新接上，或者一个新的slave加入到bond中，接收流量在所有当前激活的slave中全部重新分配，通过使用指定的MAC地址给每个 client发起ARP应答。下面介绍的updelay参数必须被设置为某个大于等于switch(交换机)转发延时的值，从而保证发往对端的ARP应答 不会被switch(交换机)阻截。")]),a._v(" "),v("p",[a._v("必要条件：")]),a._v(" "),v("ul",[v("li",[a._v("条件1：ethtool支持获取每个slave的速率；")]),a._v(" "),v("li",[a._v("条件2：底层驱动支持设置某个设备的硬件地址，从而使得总是有个slave(curr_active_slave)使用bond的硬件地址，同时保证每个bond 中的slave都有一个唯一的硬件地址。如果curr_active_slave出故障，它的硬件地址将会被新选出来的 curr_active_slave接管其实mod=6与mod=0的区别：mod=6，先把eth0流量占满，再占eth1，….ethX；而mod=0的话，会发现2个口的流量都很稳定，基本一样的带宽。而mod=6，会发现第一个口流量很高，第2个口只占了小部分流量。")])]),a._v(" "),v("h2",{attrs:{id:"注意"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[a._v("#")]),a._v(" 注意")]),a._v(" "),v("p",[a._v("mode5和mode6不需要交换机端的设置，网卡能自动聚合。mode4需要支持802.3ad。mode0，mode2和mode3理论上需要静态聚合方式。")]),a._v(" "),v("p",[a._v("但实测中mode0可以通过mac地址欺骗的方式在交换机不设置的情况下不太均衡地进行接收。")])])}),[],!1,null,null,null);v.default=e.exports}}]);